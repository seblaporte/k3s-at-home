name: Trivy Scan (Renovate PR Only)

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  trivy:
    runs-on: ubuntu-latest

    env:
      TRIVY_CACHE_DIR: .trivycache

    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch base branch
        run: git fetch origin ${{ github.base_ref }}

      # ðŸ”¥ Cache Trivy DB
      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: .trivycache
          key: trivy-cache-${{ runner.os }}
          restore-keys: |
            trivy-cache-

      - name: Extract updated image from diff
        id: image
        run: |
          git diff origin/${{ github.base_ref }} > diff.txt

          # Trouve le fichier modifiÃ©
          FILE=$(git diff --name-only origin/${{ github.base_ref }} | head -n1)

          # Utilise yq pour reconstruire l'image repository:tag proprement
          IMAGE=$(yq eval '
            .. | select(has("repository") and has("tag")) | 
            .repository + ":" + .tag
          ' "$FILE" 2>/dev/null | head -n1)

          # fallback simple si image: est directement sur la ligne
          if [ -z "$IMAGE" ]; then
            IMAGE=$(grep '^+.*image:' diff.txt | sed 's/^+//' | awk '{print $2}' | tr -d '"')
          fi

          if [ -z "$IMAGE" ]; then
            echo "NO_IMAGE=true" >> $GITHUB_ENV
            echo "No image detected, skipping scan."
          else
            echo "NO_IMAGE=false" >> $GITHUB_ENV
            echo "IMAGE=$IMAGE" >> $GITHUB_ENV
            echo "Detected image: $IMAGE"
          fi

      - name: Stop if no image changes
        if: env.NO_IMAGE == 'true'
        run: echo "No image changes detected. Skipping scan."

      - name: Setup & Scan with Trivy
        if: env.NO_IMAGE == 'false'
        uses: aquasecurity/trivy-action@0.34.0
        with:
          scan-type: 'image'
          image-ref: ${{ env.IMAGE }}
          format: 'json'
          output: 'result.json'
          severity: 'HIGH,CRITICAL'
          cache-dir: ${{ env.TRIVY_CACHE_DIR }}
        continue-on-error: true

      - name: Generate Markdown report
        if: env.NO_IMAGE == 'false'
        run: |
          IMAGE="${{ env.IMAGE }}"

          echo "# ðŸ” Trivy Scan Report" > report.md
          echo "" >> report.md

          # RÃ©sumÃ© global
          CRIT_TOTAL=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' result.json)
          HIGH_TOTAL=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="HIGH")] | length' result.json)
          MEDIUM_TOTAL=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="MEDIUM")] | length' result.json)
          LOW_TOTAL=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="LOW")] | length' result.json)

          echo "## ðŸ“Š RÃ©sumÃ©" >> report.md
          echo "- ðŸ”´ Critical: $CRIT_TOTAL" >> report.md
          echo "- ðŸ”¶ High: $HIGH_TOTAL" >> report.md
          echo "- ðŸŸ¡ Medium: $MEDIUM_TOTAL" >> report.md
          echo "- ðŸŸ¢ Low: $LOW_TOTAL" >> report.md
          echo "" >> report.md
          echo "---" >> report.md

          # DÃ©tails pour l'image unique
          echo "## ðŸ³ Image: $IMAGE" >> report.md
          echo "" >> report.md

          jq -r '
            .Results[].Vulnerabilities[]? |
            "- **\(.Severity)**: \(.PkgName) \(.InstalledVersion) â†’ \(.FixedVersion // "N/A") (`\(.VulnerabilityID)`) - \(.PrimaryURL // "no link")"
          ' result.json >> report.md || echo "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e" >> report.md

      - name: Upsert PR Comment
        if: env.NO_IMAGE == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('report.md', 'utf8');
            const marker = '<!-- trivy-report -->';
            const finalBody = marker + '\n' + body;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.find(c => c.body.startsWith(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: finalBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: finalBody
              });
            }